<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>DSE Ray Diagram (Slim UI)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { overscroll-behavior: none; }
        .lab-grid {
            background-color: #ffffff;
            background-image: linear-gradient(#f1f5f9 1px, transparent 1px), linear-gradient(90deg, #f1f5f9 1px, transparent 1px);
            background-size: 20px 20px;
        }
        
        .nature-box {
            @apply text-center py-1 px-2 text-xs font-black uppercase tracking-wide rounded-md shadow-sm transition-colors duration-300;
        }
        .nature-real { @apply bg-blue-100 text-blue-800 border border-blue-200; }
        .nature-virtual { @apply bg-yellow-100 text-yellow-800 border border-yellow-200; }
        .nature-infinity { @apply bg-slate-200 text-slate-600 border border-slate-300; }

        .stat-item {
            @apply flex flex-col items-center justify-center bg-white px-1 py-0.5 rounded border border-slate-200 shadow-sm min-w-[40px] flex-1;
        }
        .stat-label { @apply text-[8px] uppercase font-bold text-slate-400 leading-none mb-0.5; }
        .stat-val { @apply text-[10px] font-mono font-bold text-slate-800 leading-none; }

        /* BUTTON STYLE UPDATED: Smaller padding, smaller font */
        .case-btn {
            @apply flex flex-col items-center justify-center py-1 px-0.5 text-[9px] font-bold bg-white border border-slate-300 rounded shadow-sm text-slate-600 transition-all active:scale-95 leading-tight text-center h-full;
        }
        .case-btn.active {
            @apply bg-slate-800 text-white border-slate-800 shadow-md ring-1 ring-slate-800;
        }

        .toggle-eye {
            @apply absolute bottom-6 right-6 flex items-center gap-2 px-3 py-2 bg-white/95 backdrop-blur border border-slate-300 rounded-full shadow-xl text-xs font-bold text-slate-700 active:scale-95 transition-transform select-none z-50 cursor-pointer;
        }
        .toggle-eye.active {
            @apply bg-green-100 border-green-500 text-green-700 ring-2 ring-green-200;
        }
        .hidden-ctrl { display: none !important; }
    </style>
</head>
<body class="bg-slate-50 h-screen w-screen flex flex-col overflow-hidden text-slate-800">

    <div class="flex-none bg-white border-b border-slate-200 z-30 shadow-md p-1.5 flex flex-col gap-1.5">
        <div id="natureBox" class="nature-box nature-virtual">Loading...</div>
        <div class="flex gap-1 justify-between">
            <div class="stat-item border-b-2 border-slate-400"><span class="stat-label">f</span><span id="disp-f" class="stat-val">--</span></div>
            <div class="stat-item border-b-2 border-black"><span class="stat-label">u</span><span id="disp-u" class="stat-val">--</span></div>
            <div class="stat-item border-b-2 border-blue-500"><span class="stat-label">v</span><span id="disp-v" class="stat-val">--</span></div>
            <div class="stat-item border-b-2 border-purple-500"><span class="stat-label">Mag</span><span id="disp-m" class="stat-val">--</span></div>
            <div class="stat-item border-b-2 border-green-600 bg-green-50"><span class="stat-label">Ho</span><span id="disp-ho" class="stat-val">--</span></div>
            <div class="stat-item border-b-2 border-orange-500 bg-orange-50"><span class="stat-label">Hi</span><span id="disp-hi" class="stat-val">--</span></div>
        </div>
    </div>

    <div class="flex-none flex flex-col bg-slate-100 border-b border-slate-200 z-20">
        <div class="flex items-center gap-2 p-1.5 border-b border-slate-200 bg-white">
            <select id="lensSelect" onchange="manualUpdate()" class="text-[10px] p-1 border rounded bg-white flex-none w-16 font-bold shadow-sm">
                <option value="convex">Convex</option>
                <option value="concave">Concave</option>
            </select>
            <span class="text-[10px] font-bold text-slate-400">u:</span>
            <input type="range" id="uRange" min="20" max="600" value="200" oninput="manualUpdate()" class="flex-1 h-5 accent-slate-600">
        </div>
        <div class="grid grid-cols-4 gap-1 p-1">
            <button onclick="setCase(1)" id="btn1" class="case-btn">1. u &lt; f<br><span class="text-[8px] font-normal opacity-75">Virtual</span></button>
            <button onclick="setCase(2)" id="btn2" class="case-btn">2. u = f<br><span class="text-[8px] font-normal opacity-75">Infinity</span></button>
            <button onclick="setCase(3)" id="btn3" class="case-btn">3. f-2f<br><span class="text-[8px] font-normal opacity-75">Mag. Real</span></button>
            <button onclick="setCase(4)" id="btn4" class="case-btn">4. u = 2f<br><span class="text-[8px] font-normal opacity-75">Same</span></button>
            <button onclick="setCase(5)" id="btn5" class="case-btn">5. u &gt; 2f<br><span class="text-[8px] font-normal opacity-75">Dim. Real</span></button>
            <button onclick="setCase(6)" id="btn6" class="case-btn">6. Conv ‚àû<br><span class="text-[8px] font-normal opacity-75">Distant</span></button>
            <button onclick="setCase(7)" id="btn7" class="case-btn bg-slate-50 border-slate-200 text-slate-500">7. Conc ‚àû<br><span class="text-[8px] font-normal opacity-75">Virtual</span></button>
            <button onclick="setCase(8)" id="btn8" class="case-btn bg-slate-50 border-slate-200 text-slate-500">8. Conc<br><span class="text-[8px] font-normal opacity-75">Finite</span></button>
        </div>
    </div>

    <main class="flex-1 relative w-full overflow-hidden bg-white">
        <canvas id="canvas" class="w-full h-full lab-grid block cursor-crosshair"></canvas>
        <button id="eyeBtn" onclick="toggleEye()" class="toggle-eye hidden-ctrl">
            <span class="text-base">üëÅÔ∏è</span> Show Eye
        </button>
    </main>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width, height, cx, cy;
        const F_VAL = 120; const HO_VAL = 60; const INF_SLOPE = 0.15;
        
        let state = {
            lens: 'convex', u: 80, infinity: false, caseNum: 1, showEye: true,
            v: 0, m: 0, hi: 0, nature: ""
        };

        function calculatePhysics() {
            const f = state.lens === 'convex' ? F_VAL : -F_VAL;
            const u = state.u;
            if (state.infinity) { state.v = f; state.m = 0; }
            else if (u === Math.abs(f) && state.lens === 'convex') { state.v = Infinity; state.m = Infinity; }
            else { state.v = (u * f) / (u - f); state.m = Math.abs(state.v / u); }
            state.hi = HO_VAL * state.m;

            if (state.lens === 'convex') {
                if (state.infinity) state.nature = "Real, Inverted, Diminished";
                else if (u < F_VAL) state.nature = "Virtual, Erect, Magnified";
                else if (u === F_VAL) state.nature = "Image at Infinity";
                else if (u > F_VAL && u < 2*F_VAL) state.nature = "Real, Inverted, Magnified";
                else if (u === 2*F_VAL) state.nature = "Real, Inverted, Same Size";
                else state.nature = "Real, Inverted, Diminished";
            } else {
                state.nature = "Virtual, Erect, Diminished";
            }
        }

        function resize() {
            canvas.width = canvas.offsetWidth; canvas.height = canvas.offsetHeight;
            width = canvas.width; height = canvas.height; cx = width / 2; cy = height / 2; draw();
        }
        window.addEventListener('resize', resize);

        function toggleEye() { state.showEye = !state.showEye; updateEyeBtnStyle(); draw(); }

        function updateUI() {
            const box = document.getElementById('natureBox'); box.innerText = state.nature;
            box.className = 'nature-box'; 
            if (state.v === Infinity || state.infinity) {
                if (state.lens === 'concave') box.classList.add('nature-virtual');
                else if (state.caseNum === 2) box.classList.add('nature-infinity');
                else box.classList.add('nature-real');
            } else if (state.v < 0) { box.classList.add('nature-virtual'); } else { box.classList.add('nature-real'); }
            
            const fDisp = state.lens === 'concave' ? -F_VAL : F_VAL;
            document.getElementById('disp-f').innerText = fDisp;
            document.getElementById('disp-u').innerText = state.infinity ? "‚àû" : state.u;
            document.getElementById('disp-ho').innerText = HO_VAL;
            
            if (state.v === Infinity) {
                document.getElementById('disp-v').innerText = "‚àû"; document.getElementById('disp-m').innerText = "‚àû"; document.getElementById('disp-hi').innerText = "‚àû";
            } else {
                document.getElementById('disp-v').innerText = state.v.toFixed(1);
                document.getElementById('disp-m').innerText = state.m.toFixed(2) + "x";
                document.getElementById('disp-hi').innerText = state.hi.toFixed(1);
            }
        }

        function draw() {
            calculatePhysics(); updateUI(); ctx.clearRect(0, 0, width, height); drawGridBasics();
            if (state.infinity) drawInfinityCase(); 
            else if (state.v === Infinity) drawParallelCase(); 
            else drawFiniteCase();
        }

        function drawGridBasics() {
            ctx.beginPath(); ctx.strokeStyle = "#e2e8f0"; ctx.lineWidth = 1;
            ctx.moveTo(0, cy); ctx.lineTo(width, cy); ctx.stroke();
            ctx.beginPath(); ctx.strokeStyle = "#000"; ctx.lineWidth = 2;
            ctx.moveTo(0, cy); ctx.lineTo(width, cy); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(cx, 0); ctx.lineTo(cx, height); ctx.stroke();
            drawAxisArrows(cx, 0, height);
            drawPoint(cx, cy, "O");
            drawPoint(cx + F_VAL, cy, "F"); drawPoint(cx - F_VAL, cy, "F");
            if (cx + 2*F_VAL < width - 10) drawPoint(cx + 2*F_VAL, cy, "2F");
            if (cx - 2*F_VAL > 10) drawPoint(cx - 2*F_VAL, cy, "2F");
        }

        function drawFiniteCase() {
            const u = state.u; const v = state.v; const f = state.lens === 'convex' ? F_VAL : -F_VAL;
            const ho = HO_VAL; const hi = state.hi;
            const ox = cx - u; const oy = cy - ho; const ix = cx + v; const isVirtual = v < 0;
            const iy = isVirtual ? (cy - hi) : (cy + hi);

            drawImageArrow(ox, cy, ox, oy, "#1e293b", false);

            // Ray 1
            drawRayLine(ox, oy, cx, oy, "#ef4444"); drawRayArrow(ox + (cx-ox)*0.6, oy, 0, "#ef4444");
            if (state.lens === 'convex') {
                const s1 = ho / F_VAL; 
                drawRayLine(cx, oy, width, oy + (width-cx)*s1, "#ef4444"); drawRayArrow(cx + 40, oy + s1*40, s1, "#ef4444");
                if (isVirtual) drawRayLine(cx, oy, 0, oy - cx*s1, "#ef4444", true);
            } else {
                const s1 = -ho / F_VAL; 
                drawRayLine(cx, oy, width, oy + (width-cx)*s1, "#ef4444"); drawRayArrow(cx + 40, oy + s1*40, s1, "#ef4444");
                drawRayLine(cx, oy, cx-F_VAL, cy, "#ef4444", true);
            }

            // Ray 2
            const s2 = ho / u;
            drawRayLine(ox, oy, width, cy + (width-cx)*s2, "#9333ea"); drawRayArrow(cx + 40, cy + s2*40, s2, "#9333ea");
            if (isVirtual) drawRayLine(cx, cy, 0, cy - cx*s2, "#9333ea", true);

            if (Math.abs(ix) < 10000) drawImageArrow(ix, cy, ix, iy, "#2563eb", isVirtual);

            // Eye Logic (Only for finite cases 1 & 8)
            if (state.showEye && isVirtual) {
                const ex = width - 40; const ey = cy - 60; 
                drawEyeIcon(ex, ey);
                const m_sight = (ey - iy) / (ex - ix);
                const y_lens = iy + m_sight * (cx - ix);
                
                // Emergent Ray
                ctx.save(); ctx.strokeStyle = "#16a34a"; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(cx, y_lens); ctx.lineTo(ex, ey); ctx.stroke();
                drawRayArrow(cx + (ex-cx)*0.5, y_lens + m_sight*(ex-cx)*0.5, m_sight, "#16a34a");
                
                // Incident Ray
                ctx.beginPath(); ctx.moveTo(ox, oy); ctx.lineTo(cx, y_lens); ctx.stroke();
                const m_inc = (y_lens - oy) / (cx - ox);
                drawRayArrow(ox + (cx-ox)*0.6, oy + m_inc*(cx-ox)*0.6, m_inc, "#16a34a");
                
                // Virtual Extension
                ctx.setLineDash([4,4]); ctx.beginPath(); ctx.moveTo(cx, y_lens); ctx.lineTo(ix, iy); ctx.stroke();
                ctx.restore();
            }
        }

        function drawParallelCase() {
            const u = F_VAL; const ho = HO_VAL; const ox = cx - u; const oy = cy - ho;
            drawImageArrow(ox, cy, ox, oy, "#1e293b", false);
            drawRayLine(ox, oy, cx, oy, "#ef4444"); const s1 = ho / F_VAL;
            drawRayLine(cx, oy, width, oy + (width-cx)*s1, "#ef4444"); drawRayArrow(cx + 50, oy + s1*50, s1, "#ef4444");
            const s2 = ho / u; drawRayLine(ox, oy, width, cy + (width-cx)*s2, "#9333ea"); drawRayArrow(cx + 50, cy + s2*50, s2, "#9333ea");
            ctx.fillStyle = "#64748b"; ctx.font = "bold 12px sans-serif";
            ctx.fillText("Refracted rays are parallel", cx + 20, cy + 100); ctx.fillText("Image at Infinity", cx + 20, cy + 115);
        }

        function drawInfinityCase() {
            const rayColor = "#9333ea"; const outColor = "#ef4444"; const s = INF_SLOPE; 
            if (state.lens === 'convex') {
                drawRayLine(0, cy - s*cx, width, cy + s*(width-cx), rayColor);
                drawRayArrow(cx - 50, cy - s*50, s, rayColor); drawRayArrow(cx + 40, cy + s*40, s, rayColor);
                const gap = F_VAL * 0.6; const r2y = cy - s*cx - gap; const ly = r2y + s*cx;       
                drawRayLine(0, r2y, cx, ly, rayColor); drawRayArrow(cx - 50, ly - s*50, s, rayColor);
                const ix = cx + F_VAL; const iy = cy + s * F_VAL; const sr = (iy - ly) / (ix - cx);
                drawRayLine(cx, ly, width, ly + sr*(width-cx), outColor); drawRayArrow(cx + 40, ly + sr*40, sr, outColor);
                drawImageArrow(ix, cy, ix, iy, "#ef4444", false);
            } else {
                // --- CASE 7: Concave Infinity ---
                const f = F_VAL;
                
                // 1. Ray 1: Center Ray
                drawRayLine(0, cy - s*cx, width, cy + s*(width-cx), rayColor);
                drawRayArrow(cx - 60, cy - s*60, s, rayColor); drawRayArrow(cx + 60, cy + s*60, s, rayColor);
                
                // 2. Ray 2: Aim at Focus
                const y_lens = cy - s * f; const startY = y_lens - s * cx;
                drawRayLine(0, startY, cx, y_lens, rayColor); drawRayArrow(cx - 60, y_lens - s*60, s, rayColor);
                drawRayLine(cx, y_lens, cx + f, cy, "#cbd5e1", true); 
                drawRayLine(cx, y_lens, width, y_lens, outColor); drawRayArrow(cx + 60, y_lens, 0, outColor);
                
                // 3. Image
                const ix = cx - f; const iy = y_lens; drawRayLine(cx, y_lens, ix, iy, outColor, true);
                drawImageArrow(ix, cy, ix, iy, "#ef4444", true);
            }
        }

        function drawImageArrow(x1, y1, x2, y2, color, dashed) {
            ctx.beginPath(); ctx.strokeStyle = color; ctx.lineWidth = 3;
            if (dashed) ctx.setLineDash([5, 5]); else ctx.setLineDash([]);
            ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke(); ctx.setLineDash([]);
            const angle = Math.atan2(y2-y1, x2-x1); const headLen = 10;
            ctx.beginPath(); ctx.fillStyle = color; ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - headLen * Math.cos(angle - Math.PI/6), y2 - headLen * Math.sin(angle - Math.PI/6));
            ctx.lineTo(x2 - headLen * Math.cos(angle + Math.PI/6), y2 - headLen * Math.sin(angle + Math.PI/6));
            ctx.fill();
        }
        function drawRayArrow(x, y, slope, color) {
            const angle = Math.atan(slope); const headLen = 8;
            ctx.beginPath(); ctx.fillStyle = color;
            ctx.moveTo(x + headLen * Math.cos(angle), y + headLen * Math.sin(angle));
            ctx.lineTo(x - headLen * Math.cos(angle - 0.5), y - headLen * Math.sin(angle - 0.5));
            ctx.lineTo(x - headLen * Math.cos(angle + 0.5), y - headLen * Math.sin(angle + 0.5));
            ctx.fill();
        }
        function drawRayLine(x1, y1, x2, y2, color, dashed=false) {
            ctx.beginPath(); ctx.strokeStyle = color; ctx.lineWidth = 2;
            if(dashed) ctx.setLineDash([4, 4]); else ctx.setLineDash([]);
            ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke(); ctx.setLineDash([]);
        }
        function drawEyeIcon(x, y) {
            const size = 20;
            ctx.save(); ctx.lineWidth = 2; ctx.strokeStyle = "#16a34a"; ctx.fillStyle = "#fff";
            ctx.beginPath(); ctx.moveTo(x + size, y); 
            ctx.quadraticCurveTo(x, y - size*0.8, x - size*0.5, y - 4);
            ctx.quadraticCurveTo(x - size*0.8, y, x - size*0.5, y + 4);
            ctx.quadraticCurveTo(x, y + size*0.8, x + size, y);
            ctx.fill(); ctx.stroke();
            ctx.beginPath(); ctx.fillStyle = "#16a34a"; ctx.arc(x - size*0.4, y, 3, 0, Math.PI*2); ctx.fill(); ctx.restore();
        }
        function drawPoint(x, y, label) {
            ctx.beginPath(); ctx.fillStyle = "black"; ctx.arc(x, y, 3, 0, Math.PI*2); ctx.fill();
            if(label) { ctx.font = "10px sans-serif"; ctx.fillText(label, x-4, y+14); }
        }
        function drawAxisArrows(x, y1, y2) {
            ctx.fillStyle = "black"; const type = state.lens; ctx.beginPath();
            if(type === 'convex') { ctx.moveTo(x, y1); ctx.lineTo(x-4, y1+8); ctx.lineTo(x+4, y1+8); } 
            else { ctx.moveTo(x, y1+8); ctx.lineTo(x-4, y1); ctx.lineTo(x+4, y1); } ctx.fill();
            ctx.beginPath(); if(type === 'convex') { ctx.moveTo(x, y2); ctx.lineTo(x-4, y2-8); ctx.lineTo(x+4, y2-8); } 
            else { ctx.moveTo(x, y2-8); ctx.lineTo(x-4, y2); ctx.lineTo(x+4, y2); } ctx.fill();
        }

        function updateEyeBtnStyle() {
            const btn = document.getElementById('eyeBtn');
            const isVirtual = !state.infinity && ((state.lens === 'convex' && state.u < F_VAL) || state.lens === 'concave');
            if (isVirtual) { btn.classList.remove('hidden-ctrl'); if(state.showEye) btn.classList.add('active'); else btn.classList.remove('active'); } 
            else { btn.classList.add('hidden-ctrl'); }
        }
        function manualUpdate() {
            state.lens = document.getElementById('lensSelect').value; state.u = parseInt(document.getElementById('uRange').value); state.infinity = false;
            const f = F_VAL;
            if (state.lens === 'convex') {
                if (state.u < f) state.caseNum = 1; else if (state.u === f) state.caseNum = 2; else if (state.u > f && state.u < 2*f) state.caseNum = 3; else if (state.u === 2*f) state.caseNum = 4; else state.caseNum = 5;
            } else { state.caseNum = 8; }
            updateEyeBtnStyle(); document.querySelectorAll('.case-btn').forEach(b => b.classList.remove('active')); draw();
        }
        function setCase(n) {
            state.caseNum = n; document.querySelectorAll('.case-btn').forEach(b => b.classList.remove('active')); document.getElementById('btn'+n).classList.add('active');
            const sel = document.getElementById('lensSelect'); state.infinity = false;
            if (n <= 6) { state.lens = 'convex'; sel.value = 'convex'; } else { state.lens = 'concave'; sel.value = 'concave'; }
            let targetU = 200;
            switch(n) {
                case 1: targetU = 80; break; case 2: targetU = 120; break; case 3: targetU = 180; break; case 4: targetU = 240; break; case 5: targetU = 360; break; case 6: state.infinity = true; break; case 7: state.infinity = true; break; case 8: targetU = 240; break;
            }
            state.u = targetU; if(!state.infinity) document.getElementById('uRange').value = targetU;
            state.showEye = (n === 1 || n === 8);
            updateEyeBtnStyle(); draw();
        }
        resize(); setCase(1);
    </script>
</body>
</html>
